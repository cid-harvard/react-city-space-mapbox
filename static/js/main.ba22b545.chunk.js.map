{"version":3,"sources":["../../node_modules/@turf/helpers/dist/es/index.js","../../node_modules/@turf/meta/dist/es/index.js","../../node_modules/@turf/bbox/dist/es/index.js","../../node_modules/@turf/invariant/dist/es/index.js","../../node_modules/@turf/distance/dist/es/index.js","../../node_modules/@turf/bearing/dist/es/index.js","../../node_modules/@turf/destination/dist/es/index.js","../../node_modules/@turf/along/dist/es/index.js","../../src/map/animatePoints.ts","../../src/map/Utils.ts","../../node_modules/@turf/length/dist/es/index.js","Utils.ts","../../src/map/index.ts","../../src/map/interactions.ts","../../src/map/changeColors.ts","../../src/index.tsx","useLayoutData.ts","components/OptionsBar.tsx","App.tsx","index.tsx"],"names":["factors","centimeters","earthRadius","centimetres","degrees","feet","inches","kilometers","kilometres","meters","metres","miles","millimeters","millimetres","nauticalmiles","radians","yards","geom","properties","options","feat","type","id","bbox","geometry","coordinates","Error","Array","isArray","length","isNumber","lineString","radiansToDegrees","Math","PI","degreesToRadians","num","isNaN","coordEach","geojson","callback","excludeWrapCoord","j","k","l","stopG","coords","geometryMaybeCollection","isGeometryCollection","wrapShrink","coordIndex","isFeatureCollection","isFeature","stop","features","featureIndex","geometries","geomIndex","multiFeatureIndex","geometryIndex","geomType","flattenEach","i","g","featureProperties","featureBBox","featureId","undefined","geomEach","coordinate","segmentReduce","initialValue","previousValue","started","feature$$1","segmentIndex","previousCoords","previousFeatureIndex","previousMultiIndex","prevGeomIndex","currentCoord","featureIndexCoord","multiPartIndexCoord","currentSegment","segmentEach","result","Infinity","coord","getCoord","distance","from","to","coordinates1","coordinates2","dLat","dLon","lat1","lat2","a","pow","sin","cos","units","factor","radiansToLength","atan2","sqrt","bearing","start","end","final","bear","calculateFinalBearing","lon1","lon2","b","destination","origin","longitude1","latitude1","bearingRad","lengthToRadians","latitude2","asin","along","line","travelled","overshot","direction","measureDistance","animatePoints","input","map","sourceId","highlightedId","highlightedSourceId","routes","endFeature","f","startFeature","route","lineDistance","segment","arc","counter","ease","index","steps","points","newPoint","point","feature","highlighted","icon","source","fc","featureCollection","highlightedSource","requestAnimationFrame","endNode","animate","MapMode","values","defaultGeoJsonPoint","highlightedNodeSourceId","overlaySourceId","overlayPath","hiddenCircle","opacity","overlayCircle","initMap","container","accessToken","cityGeoJson","cityUMapJson","initialMode","mapStyle","getPopupHTMLContent","mapboxgl","geoBbox","geoUMapBbox","style","center","zoom","maxZoom","bounds","mapLoaded","centerOverride","padding","data","paint","layout","popup","closeButton","closeOnClick","e","locationText","city","popupContent","initInteractions","mode","setToGeoMap","top","bottom","left","right","duration","setTimeout","overlaySource","setToUMap","setColors","colorMap","newColorTarget","c","d","fill","changeColors","setNewCenter","setHighlighted","updateHighlightedPointSource","targetPoint","updateHighlightedPointSourceOnLoad","MapContext","createContext","intialized","props","rootRef","children","useState","mapState","setMapState","useEffect","mapOutput","value","colorByCountryColorMap","color","proximityColors","require","centroid","default","useLayoutData","loading","error","output","setOutput","allLatCoords","allLngCoords","CITIES_GEOJSON_RAW","ID_HDC_G0","country","CTR_MN_NM","UC_NM_MN","colorNode","find","push","uMapXCoords","uMapYCoords","CITIES_UMAPJSON_RAW","forEach","x","y","minMaxLat","extent","yToLatScale","scaleLinear","domain","range","minMaxLng","xToLngScale","n","Root","styled","div","Button","button","colorScale","BOSTON_PROXIMITY_RAW","proximity","scaleQuantize","proximityColorMap","partnerId","OptionsBar","mapContext","useContext","currentCityFeature","onClick","countryColorMap","App","useRef","Fragment","node","ref","ReactDOM","render","document","getElementById"],"mappings":"kitpIASO,IAOIA,EAAU,CACjBC,YAAaC,UACbC,YAAaD,UACbE,QAVqB,UAUE,OACvBC,KAAMH,gBACNI,OAZqB,UAYC,MACtBC,WAAYL,UACZM,WAAYN,UACZO,OAfqB,UAgBrBC,OAhBqB,UAiBrBC,MAAOT,kBACPU,YAAaV,WACbW,YAAaX,WACbY,cApBqB,UAoBQ,KAC7BC,QAAS,EACTC,MAtBqB,UAsBA,QAmElB,SAAS,EAAQC,EAAMC,EAAYC,QACtB,IAAZA,IAAsBA,EAAU,IACpC,IAAIC,EAAO,CAAEC,KAAM,WASnB,OARmB,IAAfF,EAAQG,IAAYH,EAAQG,MAC5BF,EAAKE,GAAKH,EAAQG,IAElBH,EAAQI,OACRH,EAAKG,KAAOJ,EAAQI,MAExBH,EAAKF,WAAaA,GAAc,GAChCE,EAAKI,SAAWP,EACTG,EAmDJ,SAAS,EAAMK,EAAaP,EAAYC,GAE3C,QADgB,IAAZA,IAAsBA,EAAU,KAC/BM,EACD,MAAM,IAAIC,MAAM,2BAEpB,IAAKC,MAAMC,QAAQH,GACf,MAAM,IAAIC,MAAM,gCAEpB,GAAID,EAAYI,OAAS,EACrB,MAAM,IAAIH,MAAM,+CAEpB,IAAKI,EAASL,EAAY,MAAQK,EAASL,EAAY,IACnD,MAAM,IAAIC,MAAM,oCAMpB,OAAO,EAJI,CACPL,KAAM,QACNI,YAAaA,GAEIP,EAAYC,GAwG9B,SAASY,EAAWN,EAAaP,EAAYC,GAEhD,QADgB,IAAZA,IAAsBA,EAAU,IAChCM,EAAYI,OAAS,EACrB,MAAM,IAAIH,MAAM,yDAMpB,OAAO,EAJI,CACPL,KAAM,aACNI,YAAaA,GAEIP,EAAYC,GA+P9B,SAASa,EAAiBjB,GAE7B,OAAkB,KADJA,GAAW,EAAIkB,KAAKC,KACTD,KAAKC,GAS3B,SAASC,EAAiB/B,GAE7B,OADcA,EAAU,IACN6B,KAAKC,GAAM,IAsD1B,SAASJ,EAASM,GACrB,OAAQC,MAAMD,IAAgB,OAARA,IAAiBT,MAAMC,QAAQQ,GCnkBzD,SAASE,EAAUC,EAASC,EAAUC,GAEpC,GAAgB,OAAZF,EA4BJ,IA3BA,IAAIG,EACFC,EACAC,EACApB,EACAqB,EACAC,EACAC,EAGAC,EAFAC,EAAa,EACbC,EAAa,EAEb7B,EAAOkB,EAAQlB,KACf8B,EAA+B,sBAAT9B,EACtB+B,EAAqB,YAAT/B,EACZgC,EAAOF,EAAsBZ,EAAQe,SAASzB,OAAS,EAchD0B,EAAe,EAAGA,EAAeF,EAAME,IAAgB,CAS9DV,GAHAG,KALAD,EAA0BI,EACtBZ,EAAQe,SAASC,GAAc/B,SAC/B4B,EACAb,EAAQf,SACRe,IAEiC,uBAAjCQ,EAAwB1B,MAGxB0B,EAAwBS,WAAW3B,OACnC,EAEJ,IAAK,IAAI4B,EAAY,EAAGA,EAAYZ,EAAOY,IAAa,CACtD,IAAIC,EAAoB,EACpBC,EAAgB,EAMpB,GAAiB,QALjBnC,EAAWwB,EACPD,EAAwBS,WAAWC,GACnCV,GAGJ,CACAD,EAAStB,EAASC,YAClB,IAAImC,EAAWpC,EAASH,KAQxB,OANA4B,GACER,GACc,YAAbmB,GAAuC,iBAAbA,EAEvB,EADA,EAGEA,GACN,KAAK,KACH,MACF,IAAK,QACH,IAOQ,IANNpB,EACEM,EACAI,EACAK,EACAG,EACAC,GAGF,OAAO,EACTT,IACAQ,IACA,MACF,IAAK,aACL,IAAK,aACH,IAAKhB,EAAI,EAAGA,EAAII,EAAOjB,OAAQa,IAAK,CAClC,IAOQ,IANNF,EACEM,EAAOJ,GACPQ,EACAK,EACAG,EACAC,GAGF,OAAO,EACTT,IACiB,eAAbU,GAA2BF,IAEhB,eAAbE,GAA2BF,IAC/B,MACF,IAAK,UACL,IAAK,kBACH,IAAKhB,EAAI,EAAGA,EAAII,EAAOjB,OAAQa,IAAK,CAClC,IAAKC,EAAI,EAAGA,EAAIG,EAAOJ,GAAGb,OAASoB,EAAYN,IAAK,CAClD,IAOQ,IANNH,EACEM,EAAOJ,GAAGC,GACVO,EACAK,EACAG,EACAC,GAGF,OAAO,EACTT,IAEe,oBAAbU,GAAgCF,IACnB,YAAbE,GAAwBD,IAEb,YAAbC,GAAwBF,IAC5B,MACF,IAAK,eACH,IAAKhB,EAAI,EAAGA,EAAII,EAAOjB,OAAQa,IAAK,CAElC,IADAiB,EAAgB,EACXhB,EAAI,EAAGA,EAAIG,EAAOJ,GAAGb,OAAQc,IAAK,CACrC,IAAKC,EAAI,EAAGA,EAAIE,EAAOJ,GAAGC,GAAGd,OAASoB,EAAYL,IAAK,CACrD,IAOQ,IANNJ,EACEM,EAAOJ,GAAGC,GAAGC,GACbM,EACAK,EACAG,EACAC,GAGF,OAAO,EACTT,IAEFS,IAEFD,IAEF,MACF,IAAK,qBACH,IAAKhB,EAAI,EAAGA,EAAIlB,EAASgC,WAAW3B,OAAQa,IAC1C,IAEE,IADAJ,EAAUd,EAASgC,WAAWd,GAAIF,EAAUC,GAG5C,OAAO,EACX,MACF,QACE,MAAM,IAAIf,MAAM,6BAgiB1B,SAASmC,EAAYtB,EAASC,IA7N9B,SAAkBD,EAASC,GACzB,IAAIsB,EACFpB,EACAqB,EACAvC,EACAqB,EACAE,EACAC,EACAgB,EACAC,EACAC,EACAX,EAAe,EACfJ,EAAuC,sBAAjBZ,EAAQlB,KAC9B+B,EAA6B,YAAjBb,EAAQlB,KACpBgC,EAAOF,EAAsBZ,EAAQe,SAASzB,OAAS,EAczD,IAAKiC,EAAI,EAAGA,EAAIT,EAAMS,IAAK,CA4BzB,IA3BAf,EAA0BI,EACtBZ,EAAQe,SAASQ,GAAGtC,SACpB4B,EACAb,EAAQf,SACRe,EACJyB,EAAoBb,EAChBZ,EAAQe,SAASQ,GAAG5C,WACpBkC,EACAb,EAAQrB,WACR,GACJ+C,EAAcd,EACVZ,EAAQe,SAASQ,GAAGvC,KACpB6B,EACAb,EAAQhB,UACR4C,EACJD,EAAYf,EACRZ,EAAQe,SAASQ,GAAGxC,GACpB8B,EACAb,EAAQjB,QACR6C,EAIJtB,GAHAG,IAAuBD,GACc,uBAAjCA,EAAwB1B,MAGxB0B,EAAwBS,WAAW3B,OACnC,EAECkC,EAAI,EAAGA,EAAIlB,EAAOkB,IAMrB,GAAiB,QALjBvC,EAAWwB,EACPD,EAAwBS,WAAWO,GACnChB,GAgBJ,OAAQvB,EAASH,MACf,IAAK,QACL,IAAK,aACL,IAAK,aACL,IAAK,UACL,IAAK,kBACL,IAAK,eACH,IAOQ,IANNmB,EACEhB,EACA+B,EACAS,EACAC,EACAC,GAGF,OAAO,EACT,MAEF,IAAK,qBACH,IAAKxB,EAAI,EAAGA,EAAIlB,EAASgC,WAAW3B,OAAQa,IAC1C,IAOQ,IANNF,EACEhB,EAASgC,WAAWd,GACpBa,EACAS,EACAC,EACAC,GAGF,OAAO,EAEX,MAEF,QACE,MAAM,IAAIxC,MAAM,8BA/ClB,IAOQ,IANNc,EACE,KACAe,EACAS,EACAC,EACAC,GAGF,OAAO,EA0CbX,KA4GFa,CAAS7B,GAAS,SAAUf,EAAU+B,EAAcrC,EAAYK,EAAMD,GAEpE,IAiBIsC,EAjBAvC,EAAoB,OAAbG,EAAoB,KAAOA,EAASH,KAC/C,OAAQA,GACN,KAAK,KACL,IAAK,QACL,IAAK,aACL,IAAK,UACH,OAKQ,IAJNmB,EACE,EAAQhB,EAAUN,EAAY,CAAEK,KAAMA,EAAMD,GAAIA,IAChDiC,EACA,SAIJ,EAMJ,OAAQlC,GACN,IAAK,aACHuC,EAAW,QACX,MACF,IAAK,kBACHA,EAAW,aACX,MACF,IAAK,eACHA,EAAW,UAIf,IACE,IAAIF,EAAoB,EACxBA,EAAoBlC,EAASC,YAAYI,OACzC6B,IACA,CACA,IAAIW,EAAa7C,EAASC,YAAYiC,GAKtC,IAEE,IADAlB,EAAS,EALA,CACTnB,KAAMuC,EACNnC,YAAa4C,GAGUnD,GAAaqC,EAAcG,GAGlD,OAAO,MAgOf,SAASY,EAAc/B,EAASC,EAAU+B,GACxC,IAAIC,EAAgBD,EAChBE,GAAU,EAwBd,OA7IF,SAAqBlC,EAASC,GAC5BqB,EAAYtB,GAAS,SAAUmC,EAAYnB,EAAcG,GACvD,IAAIiB,EAAe,EAGnB,GAAKD,EAAWlD,SAAhB,CAEA,IAAIH,EAAOqD,EAAWlD,SAASH,KAC/B,GAAa,UAATA,GAA6B,eAATA,EAAxB,CAGA,IAAIuD,EACAC,EAAuB,EACvBC,EAAqB,EACrBC,EAAgB,EACpB,OAyCQ,IAxCNzC,EACEoC,GACA,SACEM,EACA9B,EACA+B,EACAC,EACAvB,GAGA,QACqBQ,IAAnBS,GACArB,EAAesB,GACfK,EAAsBJ,GACtBnB,EAAgBoB,EAOhB,OALAH,EAAiBI,EACjBH,EAAuBtB,EACvBuB,EAAqBI,EACrBH,EAAgBpB,OAChBgB,EAAe,GAGjB,IAAIQ,EAAiBpD,EACnB,CAAC6C,EAAgBI,GACjBN,EAAWxD,YAEb,IAOQ,IANNsB,EACE2C,EACA5B,EACAG,EACAC,EACAgB,GAGF,OAAO,EACTA,IACAC,EAAiBI,WAvCvB,OAuGFI,CACE7C,GACA,SACE4C,EACA5B,EACAG,EACAC,EACAgB,GAGEH,GADc,IAAZC,QAAsCN,IAAjBI,EACPY,EAEA3C,EACdgC,EACAW,EACA5B,EACAG,EACAC,EACAgB,GAEJF,GAAU,KAGPD,ECn/BT,SAASjD,EAAKgB,GACV,IAAI8C,EAAS,CAACC,IAAUA,KAAWA,KAAWA,KAe9C,OAdAhD,EAAUC,GAAS,SAAUgD,GACrBF,EAAO,GAAKE,EAAM,KAClBF,EAAO,GAAKE,EAAM,IAElBF,EAAO,GAAKE,EAAM,KAClBF,EAAO,GAAKE,EAAM,IAElBF,EAAO,GAAKE,EAAM,KAClBF,EAAO,GAAKE,EAAM,IAElBF,EAAO,GAAKE,EAAM,KAClBF,EAAO,GAAKE,EAAM,OAGnBF,EClBJ,SAASG,EAASD,GACrB,IAAKA,EACD,MAAM,IAAI7D,MAAM,qBAEpB,IAAKC,MAAMC,QAAQ2D,GAAQ,CACvB,GAAmB,YAAfA,EAAMlE,MACa,OAAnBkE,EAAM/D,UACkB,UAAxB+D,EAAM/D,SAASH,KACf,OAAOkE,EAAM/D,SAASC,YAE1B,GAAmB,UAAf8D,EAAMlE,KACN,OAAOkE,EAAM9D,YAGrB,GAAIE,MAAMC,QAAQ2D,IACdA,EAAM1D,QAAU,IACfF,MAAMC,QAAQ2D,EAAM,MACpB5D,MAAMC,QAAQ2D,EAAM,IACrB,OAAOA,EAEX,MAAM,IAAI7D,MAAM,sDCPpB,SAAS+D,EAASC,EAAMC,EAAIxE,QACR,IAAZA,IAAsBA,EAAU,IACpC,IAAIyE,EAAeJ,EAASE,GACxBG,EAAeL,EAASG,GACxBG,EAAO3D,EAAiB0D,EAAa,GAAKD,EAAa,IACvDG,EAAO5D,EAAiB0D,EAAa,GAAKD,EAAa,IACvDI,EAAO7D,EAAiByD,EAAa,IACrCK,EAAO9D,EAAiB0D,EAAa,IACrCK,EAAIjE,KAAKkE,IAAIlE,KAAKmE,IAAIN,EAAO,GAAI,GACjC7D,KAAKkE,IAAIlE,KAAKmE,IAAIL,EAAO,GAAI,GAAK9D,KAAKoE,IAAIL,GAAQ/D,KAAKoE,IAAIJ,GAChE,OJicG,SAAyBlF,EAASuF,QACvB,IAAVA,IAAoBA,EAAQ,cAChC,IAAIC,EAASvG,EAAQsG,GACrB,IAAKC,EACD,MAAM,IAAI7E,MAAM4E,EAAQ,qBAE5B,OAAOvF,EAAUwF,EIvcVC,CAAgB,EAAIvE,KAAKwE,MAAMxE,KAAKyE,KAAKR,GAAIjE,KAAKyE,KAAK,EAAIR,IAAK/E,EAAQmF,OCVpE,SAASK,EAAQC,EAAOC,EAAK1F,GAGxC,QAFgB,IAAZA,IAAsBA,EAAU,KAEd,IAAlBA,EAAQ2F,MACR,OAqBR,SAA+BF,EAAOC,GAElC,IAAIE,EAAOJ,EAAQE,EAAKD,GAExB,OADAG,GAAQA,EAAO,KAAO,IAxBXC,CAAsBJ,EAAOC,GAExC,IAAIjB,EAAeJ,EAASoB,GACxBf,EAAeL,EAASqB,GACxBI,EAAO9E,EAAiByD,EAAa,IACrCsB,EAAO/E,EAAiB0D,EAAa,IACrCG,EAAO7D,EAAiByD,EAAa,IACrCK,EAAO9D,EAAiB0D,EAAa,IACrCK,EAAIjE,KAAKmE,IAAIc,EAAOD,GAAQhF,KAAKoE,IAAIJ,GACrCkB,EAAIlF,KAAKoE,IAAIL,GAAQ/D,KAAKmE,IAAIH,GAC9BhE,KAAKmE,IAAIJ,GAAQ/D,KAAKoE,IAAIJ,GAAQhE,KAAKoE,IAAIa,EAAOD,GACtD,OAAOjF,EAAiBC,KAAKwE,MAAMP,EAAGiB,ICX3B,SAASC,EAAYC,EAAQ5B,EAAUkB,EAASxF,QAC3C,IAAZA,IAAsBA,EAAU,IAEpC,IAAIyE,EAAeJ,EAAS6B,GACxBC,EAAanF,EAAiByD,EAAa,IAC3C2B,EAAYpF,EAAiByD,EAAa,IAC1C4B,EAAarF,EAAiBwE,GAC9B5F,ENkdD,SAAyB0E,EAAUa,QACxB,IAAVA,IAAoBA,EAAQ,cAChC,IAAIC,EAASvG,EAAQsG,GACrB,IAAKC,EACD,MAAM,IAAI7E,MAAM4E,EAAQ,qBAE5B,OAAOb,EAAWc,EMxdJkB,CAAgBhC,EAAUtE,EAAQmF,OAE5CoB,EAAYzF,KAAK0F,KAAK1F,KAAKmE,IAAImB,GAAatF,KAAKoE,IAAItF,GACrDkB,KAAKoE,IAAIkB,GAAatF,KAAKmE,IAAIrF,GAAWkB,KAAKoE,IAAImB,IAKvD,OAAO,EAAM,CAFHxF,EAFOsF,EACbrF,KAAKwE,MAAMxE,KAAKmE,IAAIoB,GAAcvF,KAAKmE,IAAIrF,GAAWkB,KAAKoE,IAAIkB,GAAYtF,KAAKoE,IAAItF,GAAWkB,KAAKmE,IAAImB,GAAatF,KAAKmE,IAAIsB,KAExH1F,EAAiB0F,IACFvG,EAAQD,YCtBtB,SAAS0G,EAAMC,EAAMpC,EAAUtE,QAC1B,IAAZA,IAAsBA,EAAU,IAKpC,IAHA,IJiKoBoB,EIhKhBO,GJiKiB,aADDP,EIjKDsF,GJkKPxG,KACDkB,EAAQf,SAEZe,GIpKWd,YACdqG,EAAY,EACPhE,EAAI,EAAGA,EAAIhB,EAAOjB,UACnB4D,GAAYqC,GAAahE,IAAMhB,EAAOjB,OAAS,GADpBiC,IAAK,CAI/B,GAAIgE,GAAarC,EAAU,CAC5B,IAAIsC,EAAWtC,EAAWqC,EAC1B,GAAKC,EAGA,CACD,IAAIC,EAAYrB,EAAQ7D,EAAOgB,GAAIhB,EAAOgB,EAAI,IAAM,IAEpD,OADmBsD,EAAYtE,EAAOgB,GAAIiE,EAAUC,EAAW7G,GAJ/D,OAAO,EAAM2B,EAAOgB,IASxBgE,GAAaG,EAAgBnF,EAAOgB,GAAIhB,EAAOgB,EAAI,GAAI3C,GAG/D,OAAO,EAAM2B,EAAOA,EAAOjB,OAAS,ILfxCN,EAAI,QAAcA,EMOlB,ICtCA,EDwCM2G,EAAgB,SAACC,G,IACdC,EAAqDD,EAArDC,IAAKC,EAAgDF,EAAhDE,SAAUC,EAAsCH,EAAtCG,cAAeC,EAAuBJ,EAAvBI,oBAC/B3B,EAAQuB,EAAd,MACMtB,EAAMsB,EAAZ,IAEMK,EAAS,EAAH,GACP5B,EADO,UAEVtD,SAAUsD,EAAA,cAAmB,YAS3B,IARA,IEhCkCzF,EFgC5BsH,EACJ5B,EAAA,eAAkB,mBAAqB6B,6BAA+BC,gBAApD,cACdC,EAAQ7G,EACZ,CAAC4G,WAAD,YAAoCF,WADd,kBAElBE,EAFN,aAIME,QErCQ,IAAZ1H,IAAsBA,EAAU,IAE7BmD,EFmCL,GEnC4B,SAAUE,EAAesE,GACnD,IAAIhG,EAASgG,EAAQtH,SAASC,YAC9B,OAAO+C,EAAgBiB,EAAS3C,EAAO,GAAIA,EAAO,GAAI3B,KACvD,IFiCK4H,EAAN,GACSjF,EAAT,EAAgBA,EAAhB,EAAkCA,GAAK+E,EAlB7C,IAkBmE,CAC3D,IAAMC,EAAUlB,EAAMgB,EAAtB,GACAG,OAASD,WAATC,aAGF,OADAH,yBACA,OAIAI,EAAJ,EACIC,EAAJ,GACA,aACE,IACA,EADMC,EAAQF,GA9BlB,IA8BqCG,IAAYlH,WAA7C,GAEMmH,EAASZ,EAAA,cAAoB,YACjC,IAAMa,EAAWC,EACfC,uBADoB,QAEhBA,EAFN,aAaA,OATIjB,UAA0BiB,6BAAqCjB,EAAnE,aACEkB,EAAc,EAAH,MAETtI,WAAY,EAAF,GACLmI,EADK,YAERI,KAAM,kBAIZ,KAGIC,EAAStB,YAAf,GAKA,GAJA,GACGsB,URyPA,SAA2BpG,EAAUnC,QACxB,IAAZA,IAAsBA,EAAU,IACpC,IAAIwI,EAAK,CAAEtI,KAAM,qBAQjB,OAPIF,EAAQG,KACRqI,EAAGrI,GAAKH,EAAQG,IAEhBH,EAAQI,OACRoI,EAAGpI,KAAOJ,EAAQI,MAEtBoI,EAAGrG,SAAWA,EACPqG,EQnQmBC,CAAvBF,IAGH,EAAiB,CACf,IAAMG,EAAoBzB,YAA1B,GACA,GACGyB,aAKL,GAAIb,EA9DR,IA+DMc,6BACK,CACL,IAAMJ,EAAStB,YAAf,GAIA,GAHA,GACGsB,aAEH,EAAiB,CACf,IAAMK,EAAUlD,EAAA,eAAkB,mBAAYyB,UAA0BI,6BAA+BJ,EAArE,cAClC,KAAa,CACXkB,EAAc,EAAH,MAETtI,WAAY,EAAF,GACL6I,EADK,YAERN,KAAM,iBAGV,IAAMI,EAAoBzB,YAA1B,GACA,GACGyB,eAMTb,GADAC,EAAOD,EAAUG,GAAVH,KAAsBC,EAA7BA,IAA2CA,EAG7Ce,KC/HF,SAAYC,GACVA,YACAA,cAFF,CAAYA,MAAZ,KAKO,IE6C8BC,EF7CxBC,EAA6D,CACxE9I,KADwE,UAExEH,WAFwE,GAGxEM,SAAU,CACRH,KADQ,QAERI,YAAa,KGeX2I,EAAN,kCACMC,EAAN,yBAEMC,EAAc,CAClB,CACE,OADF,IAEE,MAFF,IAGE,CAAC,IAHH,IAIE,CAAC,KAJH,IAKE,OANJ,MASMC,EACJ,CAAClJ,KAAD,UAAkBG,SAAU,CAACH,KAAD,UAAkBI,YAAa6I,GAAcpJ,WAAY,CAACsJ,QAAS,IAC3FC,EACJ,CAACpJ,KAAD,UAAkBG,SAAU,CAACH,KAAD,UAAkBI,YAAa6I,GAAcpJ,WAAY,CAACsJ,QAAS,IAE3FE,EAAU,SAACvC,G,IAEbwC,EAEExC,EAFFwC,UAAWC,EAETzC,EAFSyC,YAAaC,EAEtB1C,EAFsB0C,YAAaC,EAEnC3C,EAFmC2C,aAAcC,EAEjD5C,EAFiD4C,YAAaC,EAE9D7C,EAF8D6C,SAChEC,EACE9C,EADF8C,oBAEFC,kBAEA,IAAMC,EAAe5J,EAArB,GACM6J,EAAmB7J,EAAzB,GAEM6G,EAAM,IAAI8C,IAAJ,IAAiB,CAC3BP,UAD2B,EAE3BU,MAF2B,EAG3BC,OAAQ,CAAC,EAHkB,IAI3BC,KAJ2B,KAK3BC,QAL2B,KAM3BC,OAAQN,IAGNO,GAAJ,EACIC,GAAJ,EAEAvD,aAAe,WACbsD,KACA,GACEtD,cAAuB,CACrBwD,QADqB,GAErB5B,SAAS,IAIb5B,cAA+B,CAC7B/G,KAD6B,UAE7BwK,KAAMd,IAAgBd,EAAhBc,MAA6CN,IAGrDrC,WAAa,CACX9G,GADW,EAEXD,KAFW,OAGXqI,OAHW,EAIXoC,MAAO,CACL,aADK,OAEL,eAAgB,CAAC,MAAO,cAI5B1D,YAhEJ,uBAgEqC,CAC/B/G,KAD+B,UAE/BwK,KAAMd,IAAgBd,EAAhBc,MAA4CD,IAGpD1C,WAAa,CACX9G,GAtEN,uBAuEMD,KAFW,SAGXqI,OAxEN,uBAyEMoC,MAAO,CAEL,gBAAiB,CAAC,cAEhB,CAAC,SAFc,MAGf,CAHe,eAFZ,IASL,eAAgB,CAAC,MAAO,WAI5B1D,cAAuC,CACrC/G,KADqC,UAErCwK,KAAM1B,IAGR/B,WAAa,CACX9G,GADW,EAEXD,KAFW,SAGXqI,OAHW,EAITqC,OAAQ,CACN,aAAc,CAAC,MADT,QAEN,YAAa,CAAC,cAEV,CAAC,cAFQ,KAGT,CAHS,gBAFP,GAWN,cAAe,CAAC,GAXV,IAYN,sBAZM,EAaN,yBAAyB,KC9HV,SAAC5D,G,IAEtBC,EACED,EADFC,IAAKC,EACHF,EADGE,SAAU4C,EACb9C,EADa8C,oBAGbe,EAAQ,IAAId,IAAJ,MAAmB,CAC7Be,aAD6B,EAE7BC,cAAc,IAIhB9D,qBAA+B,YAC7BA,qCASA,IAPA,IAAM3G,EAAe0K,mCAArB,QAGMC,EAFQD,yBAAd,KAEqBE,KADJF,yBAAjB,QAKOlK,SAASkK,aAAe1K,EAAxBQ,IAAP,KACER,MAAkB0K,aAAe1K,EAAf0K,QAAlB1K,IAGF,IAAM6K,EAAerB,EAAsBA,EAAqBkB,cAAxB,YAAxC,EAIAH,sCAIF5D,qBAA+B,WAC7BA,8BACA4D,cD+FAO,CAAiB,CAACnE,IAAD,EAAMC,SAhH3B,uBAgHwD4C,2BAGtD,IAAIuB,EAAJ,EACIlE,EAAJ,KA0GA,MAAO,CACLF,IADK,EACAqE,YAzGa,WAClB,KAAe,CACbrE,2BAEAA,cAAuB,CACrBwD,QAAS,CAACc,IAAD,IAAWC,OAAX,EAAqBC,KAArB,GAA+BC,MAAO,IAC/C7C,SAFqB,EAGrB8C,SAJF,MAMAC,YAAW,WACT7E,EAAc,CACZtB,MADY,EAEZC,IAFY,EAGZwB,SAnIV,uBAoIUD,IAJY,EAIPE,cAJO,EAKZC,oBAAqB6B,MAZzB,KAeA,IAAM4C,EAAgB5E,YAAtB,GACA,GACG4E,aAEHR,EAAOvC,EAAPuC,MAmFgBS,UA/EF,WAChB,KAAe,CACb7E,2BAEAA,cAA2B,CACzBwD,QAAS,CAACc,IAAD,IAAWC,OAAX,EAAqBC,KAArB,GAA+BC,MAAO,IAC/C7C,SAFyB,EAGzB8C,SAJF,MAMAC,YAAW,WACT7E,EAAc,CACZtB,MADY,EAEZC,IAFY,EAGZwB,SA7JV,uBA8JUD,IAJY,EAIPE,cAJO,EAKZC,oBAAqB6B,MAZzB,KAeA,IAAM4C,EAAgB5E,YAAtB,GACA,GACG4E,aAEHR,EAAOvC,EAAPuC,OAyD2BU,UArDb,SAACC,IEvLA,SAAChF,G,IACbC,EAAiCD,EAAjCC,IAAKC,EAA4BF,EAA5BE,SAAU8E,EAAkBhF,EAAlBgF,SAAUX,EAAQrE,EAARqE,KAE1B3B,EAAc1C,EAApB,YACM2C,EAAe3C,EAArB,aACA0C,gBAAyB,YACvB,IAAMuC,EAAiBD,EAAA,MAAc,SAAAE,GAAC,OAAIA,kBAAoBC,gBAAxB,cACtCA,kBAAmBA,EAAnBA,YAAiCC,KAAMH,EAAiBA,EAAH,MALvD,eAOAtC,gBAA0B,YACxB,IAAMsC,EAAiBD,EAAA,MAAc,SAAAE,GAAC,OAAIA,kBAAoBC,gBAAxB,cACtCA,kBAAmBA,EAAnBA,YAAiCC,KAAMH,EAAiBA,EAAH,MATvD,eAYA,IAAM1D,EAAStB,YAAf,GACA,KAAY,CACV,IAAMyD,EAAOW,IAASvC,EAATuC,OAAb,EACC9C,oBFuKD8D,CAAa,CACXnF,SA5KN,uBA6KMD,IAFW,EAEN+E,SAFM,EAEIX,KAFJ,EAGX3B,YAHW,EAIXC,kBAgDsC2C,aA5CrB,SAACnC,GAChBkB,IAASvC,EAAb,MACE0B,KACAvD,SAAW,CACTkD,OADS,EAETC,KAAM,MAuC4CmC,eAlCjC,SAACpM,GACtB,IAAMqM,EAA+B,WACnC,IAAMjE,EAAStB,YAAf,GACA,GAAI9G,UAAJ,EAA2B,CACzBgH,IACA,IACMsF,GADYpB,IAASvC,EAATuC,OAAlB,GACoB,eAAmB,mBAAYc,6BAA+BhM,EAA3C,cACvC,KAAiB,CACf,IAAMJ,EAAa,EAAH,GACX0M,EADW,YAEdnE,KAAM,eAEPC,kBAECxI,sBAGKwI,GACRA,cAIL,KACEiE,QACK,CAKLvF,aAJ2C,SAArCyF,IACJF,IACAvF,uBG5OF0F,EAAaC,wBAAwB,CAACC,YAAY,I,EAkBnC,SAACC,G,IAElBrD,EAEEqD,EAFFrD,YAAasD,EAEXD,EAFWC,QAASC,EAEpBF,EAFoBE,SAAUtD,EAE9BoD,EAF8BpD,YAAaC,EAE3CmD,EAF2CnD,aAAcC,EAEzDkD,EAFyDlD,YAAaC,EAEtEiD,EAFsEjD,SACxEC,EACEgD,EADFhD,oB,EAE8BmD,mBAAmB,CAACJ,YAAY,IAAzDK,OAAUC,OAcjB,OAZAC,qBAAU,WACR,IAAM5D,EAAYuD,EAAlB,QACA,GAAIvD,IAAc0D,EAAd1D,eAAJ,EAAsE,CACpE,IAAM6D,EAAY9D,EAAQ,CACxBC,UADwB,EACbC,YADa,EACAC,YADA,EACaC,aADb,EAExBC,YAAaA,GAA4Bd,EAFjB,IAGxBe,SAHwB,EAGdC,wBAEZqD,EAAY,EAAD,CAAEN,YAAY,GAAzBM,OAED,CAACJ,EAASG,EAAUxD,EAAaC,EAAcC,EAAaC,EAV/DuD,IAaE,kBAACT,EAAD,UAAqBW,MAAOJ,GAD9B,I,+BJxCWK,EAAyB,CACpC,CAACpN,GAAI,gBAAiBqN,MAAO,WAC7B,CAACrN,GAAI,SAAUqN,MAAO,WACtB,CAACrN,GAAI,OAAQqN,MAAO,WACpB,CAACrN,GAAI,SAAUqN,MAAO,WACtB,CAACrN,GAAI,QAASqN,MAAO,WACrB,CAACrN,GAAI,YAAaqN,MAAO,WACzB,CAACrN,GAAI,QAASqN,MAAO,WACrB,CAACrN,GAAI,UAAWqN,MAAO,WACvB,CAACrN,GAAI,WAAYqN,MAAO,WACxB,CAACrN,GAAI,iBAAkBqN,MAAO,WAC9B,CAACrN,GAAI,SAAUqN,MAAO,WACtB,CAACrN,GAAI,UAAWqN,MAAO,WACvB,CAACrN,GAAI,UAAWqN,MAAO,WACvB,CAACrN,GAAI,QAASqN,MAAO,WACrB,CAACrN,GAAI,SAAUqN,MAAO,WACtB,CAACrN,GAAI,SAAUqN,MAAO,WACtB,CAACrN,GAAI,UAAWqN,MAAO,WACvB,CAACrN,GAAI,iBAAkBqN,MAAO,WAC9B,CAACrN,GAAI,WAAYqN,MAAO,WACxB,CAACrN,GAAI,SAAUqN,MAAO,WACtB,CAACrN,GAAI,UAAWqN,MAAO,WACvB,CAACrN,GAAI,UAAWqN,MAAO,WACvB,CAACrN,GAAI,SAAUqN,MAAO,WACtB,CAACrN,GAAI,UAAWqN,MAAO,WACvB,CAACrN,GAAI,UAAWqN,MAAO,WACvB,CAACrN,GAAI,UAAWqN,MAAO,WACvB,CAACrN,GAAI,SAAUqN,MAAO,WACtB,CAACrN,GAAI,YAAaqN,MAAO,WACzB,CAACrN,GAAI,SAAUqN,MAAO,WACtB,CAACrN,GAAI,UAAWqN,MAAO,WACvB,CAACrN,GAAI,SAAUqN,MAAO,WACtB,CAACrN,GAAI,QAASqN,MAAO,WACrB,CAACrN,GAAI,QAASqN,MAAO,WACrB,CAACrN,GAAI,WAAYqN,MAAO,WACxB,CAACrN,GAAI,YAAaqN,MAAO,WACzB,CAACrN,GAAI,SAAUqN,MAAO,WACtB,CAACrN,GAAI,QAASqN,MAAO,WACrB,CAACrN,GAAI,cAAeqN,MAAO,YAGvBC,EAAkB,CACrB,UACA,UACA,UACA,UACA,W,iCK1CgCC,EAAQ,GAApCvF,E,EAAAA,MAAOM,E,EAAAA,kBACRkF,EAAWD,EAAQ,IAAkBE,QA+D5BC,EApDO,WAAO,IAAD,EACEZ,mBAAiB,CAACa,SAAS,EAAMC,WAAO/K,EAAW0H,UAAM1H,IAD3D,mBACnBgL,EADmB,KACXC,EADW,KAiD1B,OA9CAb,qBAAU,WACRxB,YAAW,WAET,IAAMsC,EAAyB,GACzBC,EAAyB,GAEzBzE,EAAcjB,EAAmB2F,EAA2BjM,SAAS8E,KAAI,SAACmB,GAAkB,IAAD,EAClCA,EAAQrI,WAAnDI,EAD6E,EACxFkO,UAA0BC,EAD8D,EACzEC,UAA8BrD,EAD2C,EACrDsD,SACpCC,EAAYlB,EAAuBmB,MAAK,SAAAxC,GAAC,OAAIA,EAAE/L,KAAOmO,KACtDlC,EAAOqC,EAAYA,EAAUjB,MAAQ,OACrCrF,EAAQwF,EAASvF,EAAS,CAACrI,WAAY,CAACI,KAAImO,UAASpD,OAAMkB,UAGjE,OAFA+B,EAAaQ,KAAKxG,EAAM9H,SAASC,YAAY,IAC7C4N,EAAaS,KAAKxG,EAAM9H,SAASC,YAAY,IACtC6H,MAIHyG,EAAwB,GACxBC,EAAwB,GAC9BC,EAAoBC,SAAQ,YAAa,IAAXC,EAAU,EAAVA,EAAGC,EAAO,EAAPA,EAC/BL,EAAYD,KAAKK,GACjBH,EAAYF,KAAKM,MAInB,IAAMC,EAAYC,YAAOjB,GACnBkB,EAAcC,cACjBC,OAAOH,YAAON,IACdU,MAAM,CAAgB,KAAfL,EAAU,GAA0B,IAAfA,EAAU,KAEnCM,EAAYL,YAAOhB,GACnBsB,EAAcJ,cACjBC,OAAOH,YAAOP,IACdW,MAAM,CAAgB,GAAfC,EAAU,GAAyB,EAAfA,EAAU,KAElC7F,EAAelB,EAAkBqG,EAAoB7H,KAAI,SAAAyI,GAAM,IAC5DV,EAA4DU,EAA5DV,EAAGC,EAAyDS,EAAzDT,EAAc9O,EAA2CuP,EAAtDrB,UAA0BC,EAA4BoB,EAAvCnB,UAA8BrD,EAASwE,EAAnBlB,SAC1CC,EAAYlB,EAAuBmB,MAAK,SAAAxC,GAAC,OAAIA,EAAE/L,KAAOmO,KACtDlC,EAAOqC,EAAYA,EAAUjB,MAAQ,OAC3C,OAAOrF,EAAM,CAACsH,EAAYT,GAAII,EAAYH,IAAK,CAAC9O,KAAImO,UAASpD,OAAMkB,aAGrE6B,EAAU,CAACH,SAAS,EAAOC,WAAO/K,EAAW0H,KAAM,CAACf,eAAcD,mBACjE,OACF,IAEIsE,GC7DH2B,GAAOC,IAAOC,IAAV,mEAAGD,CAAH,kIAYJE,GAASF,IAAOG,OAAV,qEAAGH,CAAH,yUAqBNI,INY+BjH,EMZG,CAAC,GAAF,mBAAQkH,EAAqBhJ,KAAI,SAAAkF,GAAC,OAAIA,EAAE+D,cAAxC,CAAoD,INalDC,cACpCb,OAAOH,YAAOpG,IACdwG,MAAM9B,IMdL2C,GAAoBH,EAAqBhJ,KAAI,gBAAEoJ,EAAF,EAAEA,UAAWH,EAAb,EAAaA,UAAb,MAA6B,CAAC/P,GAAIkQ,EAAW7C,MAAOwC,GAAWE,OAyDnGI,GAvDI,WACjB,IAAMC,EFnCaC,qBAAnB,GEoCO9F,EAAQmD,IAARnD,KAEP0C,qBAAU,WACR,GAAImD,EAAW1D,YAAcnC,EAAM,CACjC,IAAM+F,EAAqB/F,EAAKhB,YAAYvH,SAASuM,MAAK,mBAAgE,OAAhE,EAAE3O,WAAuDI,MAC/GsQ,IACFF,EAAWjE,aAAamE,EAAmBpQ,SAASC,aACpDiQ,EAAWhE,eAAe,WAoChC,OACE,kBAACoD,GAAD,KACE,kBAACG,GAAD,CAAQY,QAjCU,WAChBH,EAAW1D,YACb0D,EAAWjF,gBA+BX,UACA,kBAACwE,GAAD,CAAQY,QA5BQ,WACdH,EAAW1D,YACb0D,EAAWzE,cA0BX,QACA,kBAACgE,GAAD,CAAQY,QAvBkB,WAC5B,GAAIH,EAAW1D,YAAcnC,EAAM,CACjC,IAAMiG,EAAkBjG,EAAKhB,YAAYvH,SAAS8E,KAAI,SAACkF,GACrD,IAAMmC,EAAUf,EAAuBmB,MAAK,SAAAxC,GAAC,OAAIA,EAAE/L,KAAOgM,EAAEpM,WAAWuO,WACvE,MAAO,CACLnO,GAAIgM,EAAEpM,WAAWI,GACjBqN,MAAOc,EAAUA,EAAQd,MAAQ,WAGrC+C,EAAWxE,UAAU4E,MAcrB,oBACA,kBAACb,GAAD,CAAQY,QAXsB,WAC5BH,EAAW1D,YACb0D,EAAWxE,UAAUqE,MASrB,wBCvFAT,GAAOC,IAAOC,IAAV,4DAAGD,CAAH,8CAsCKgB,GA7BH,WACV,IAAM7D,EAAU8D,iBAA8B,MACvCnG,EAAQmD,IAARnD,KAUP,OACE,kBAAC,IAAMoG,SAAP,KACE,kBAAC,EAAD,CACErH,YAjBN,wGAkBMI,SAAU,6DACVkD,QAASA,EACTrD,YAAagB,EAAOA,EAAKhB,iBAAc1G,EACvC2G,aAAce,EAAOA,EAAKf,kBAAe3G,EACzC8G,oBAhBuB,SAACiH,GAC5B,MAAM,kCAAN,OAEcA,EAAK7F,KAFnB,iDAIW6F,EAAKzC,QAJhB,oBAiBI,kBAAC,GAAD,OAEF,kBAAC,GAAD,CAAM0C,IAAKjE,MCjCjBkE,IAASC,OAAO,kBAAC,GAAD,MAASC,SAASC,eAAe,W","file":"static/js/main.ba22b545.chunk.js","sourcesContent":["/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexport var earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var factors = {\n    centimeters: earthRadius * 100,\n    centimetres: earthRadius * 100,\n    degrees: earthRadius / 111325,\n    feet: earthRadius * 3.28084,\n    inches: earthRadius * 39.37,\n    kilometers: earthRadius / 1000,\n    kilometres: earthRadius / 1000,\n    meters: earthRadius,\n    metres: earthRadius,\n    miles: earthRadius / 1609.344,\n    millimeters: earthRadius * 1000,\n    millimetres: earthRadius * 1000,\n    nauticalmiles: earthRadius / 1852,\n    radians: 1,\n    yards: earthRadius / 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.37,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / earthRadius,\n    yards: 1 / 1.0936,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    hectares: 0.0001,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nexport function feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nexport function geometry(type, coordinates, _options) {\n    if (_options === void 0) { _options = {}; }\n    switch (type) {\n        case \"Point\":\n            return point(coordinates).geometry;\n        case \"LineString\":\n            return lineString(coordinates).geometry;\n        case \"Polygon\":\n            return polygon(coordinates).geometry;\n        case \"MultiPoint\":\n            return multiPoint(coordinates).geometry;\n        case \"MultiLineString\":\n            return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\":\n            return multiPolygon(coordinates).geometry;\n        default:\n            throw new Error(type + \" is invalid\");\n    }\n}\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nexport function point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (!coordinates) {\n        throw new Error(\"coordinates is required\");\n    }\n    if (!Array.isArray(coordinates)) {\n        throw new Error(\"coordinates must be an Array\");\n    }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be at least 2 numbers long\");\n    }\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\n        throw new Error(\"coordinates must contain numbers\");\n    }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nexport function points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nexport function polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nexport function polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nexport function lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nexport function lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nexport function featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nexport function multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nexport function multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nexport function multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nexport function geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nexport function round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nexport function radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nexport function lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nexport function lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nexport function bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nexport function radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return (degrees * 180) / Math.PI;\n}\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nexport function degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return (radians * Math.PI) / 180;\n}\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nexport function convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches, hectares\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted area\n */\nexport function convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nexport function isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nexport function isObject(input) {\n    return !!input && input.constructor === Object;\n}\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nexport function validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nexport function validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\n","import { feature, point, lineString, isObject } from '@turf/helpers';\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n  // Handles null Geometry -- Skips this GeoJSON\n  if (geojson === null) return;\n  var j,\n    k,\n    l,\n    geometry,\n    stopG,\n    coords,\n    geometryMaybeCollection,\n    wrapShrink = 0,\n    coordIndex = 0,\n    isGeometryCollection,\n    type = geojson.type,\n    isFeatureCollection = type === \"FeatureCollection\",\n    isFeature = type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n    geometryMaybeCollection = isFeatureCollection\n      ? geojson.features[featureIndex].geometry\n      : isFeature\n      ? geojson.geometry\n      : geojson;\n    isGeometryCollection = geometryMaybeCollection\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\n      : false;\n    stopG = isGeometryCollection\n      ? geometryMaybeCollection.geometries.length\n      : 1;\n\n    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n      var multiFeatureIndex = 0;\n      var geometryIndex = 0;\n      geometry = isGeometryCollection\n        ? geometryMaybeCollection.geometries[geomIndex]\n        : geometryMaybeCollection;\n\n      // Handles null Geometry -- Skips this geometry\n      if (geometry === null) continue;\n      coords = geometry.coordinates;\n      var geomType = geometry.type;\n\n      wrapShrink =\n        excludeWrapCoord &&\n        (geomType === \"Polygon\" || geomType === \"MultiPolygon\")\n          ? 1\n          : 0;\n\n      switch (geomType) {\n        case null:\n          break;\n        case \"Point\":\n          if (\n            callback(\n              coords,\n              coordIndex,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false\n          )\n            return false;\n          coordIndex++;\n          multiFeatureIndex++;\n          break;\n        case \"LineString\":\n        case \"MultiPoint\":\n          for (j = 0; j < coords.length; j++) {\n            if (\n              callback(\n                coords[j],\n                coordIndex,\n                featureIndex,\n                multiFeatureIndex,\n                geometryIndex\n              ) === false\n            )\n              return false;\n            coordIndex++;\n            if (geomType === \"MultiPoint\") multiFeatureIndex++;\n          }\n          if (geomType === \"LineString\") multiFeatureIndex++;\n          break;\n        case \"Polygon\":\n        case \"MultiLineString\":\n          for (j = 0; j < coords.length; j++) {\n            for (k = 0; k < coords[j].length - wrapShrink; k++) {\n              if (\n                callback(\n                  coords[j][k],\n                  coordIndex,\n                  featureIndex,\n                  multiFeatureIndex,\n                  geometryIndex\n                ) === false\n              )\n                return false;\n              coordIndex++;\n            }\n            if (geomType === \"MultiLineString\") multiFeatureIndex++;\n            if (geomType === \"Polygon\") geometryIndex++;\n          }\n          if (geomType === \"Polygon\") multiFeatureIndex++;\n          break;\n        case \"MultiPolygon\":\n          for (j = 0; j < coords.length; j++) {\n            geometryIndex = 0;\n            for (k = 0; k < coords[j].length; k++) {\n              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                if (\n                  callback(\n                    coords[j][k][l],\n                    coordIndex,\n                    featureIndex,\n                    multiFeatureIndex,\n                    geometryIndex\n                  ) === false\n                )\n                  return false;\n                coordIndex++;\n              }\n              geometryIndex++;\n            }\n            multiFeatureIndex++;\n          }\n          break;\n        case \"GeometryCollection\":\n          for (j = 0; j < geometry.geometries.length; j++)\n            if (\n              coordEach(geometry.geometries[j], callback, excludeWrapCoord) ===\n              false\n            )\n              return false;\n          break;\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n  }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n  var previousValue = initialValue;\n  coordEach(\n    geojson,\n    function (\n      currentCoord,\n      coordIndex,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex\n    ) {\n      if (coordIndex === 0 && initialValue === undefined)\n        previousValue = currentCoord;\n      else\n        previousValue = callback(\n          previousValue,\n          currentCoord,\n          coordIndex,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    },\n    excludeWrapCoord\n  );\n  return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n  var i;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      for (i = 0; i < geojson.features.length; i++) {\n        if (callback(geojson.features[i].properties, i) === false) break;\n      }\n      break;\n    case \"Feature\":\n      callback(geojson.properties, 0);\n      break;\n  }\n}\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  propEach(geojson, function (currentProperties, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined)\n      previousValue = currentProperties;\n    else\n      previousValue = callback(previousValue, currentProperties, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n  if (geojson.type === \"Feature\") {\n    callback(geojson, 0);\n  } else if (geojson.type === \"FeatureCollection\") {\n    for (var i = 0; i < geojson.features.length; i++) {\n      if (callback(geojson.features[i], i) === false) break;\n    }\n  }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  featureEach(geojson, function (currentFeature, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined)\n      previousValue = currentFeature;\n    else previousValue = callback(previousValue, currentFeature, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n  var coords = [];\n  coordEach(geojson, function (coord) {\n    coords.push(coord);\n  });\n  return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n  var i,\n    j,\n    g,\n    geometry,\n    stopG,\n    geometryMaybeCollection,\n    isGeometryCollection,\n    featureProperties,\n    featureBBox,\n    featureId,\n    featureIndex = 0,\n    isFeatureCollection = geojson.type === \"FeatureCollection\",\n    isFeature = geojson.type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (i = 0; i < stop; i++) {\n    geometryMaybeCollection = isFeatureCollection\n      ? geojson.features[i].geometry\n      : isFeature\n      ? geojson.geometry\n      : geojson;\n    featureProperties = isFeatureCollection\n      ? geojson.features[i].properties\n      : isFeature\n      ? geojson.properties\n      : {};\n    featureBBox = isFeatureCollection\n      ? geojson.features[i].bbox\n      : isFeature\n      ? geojson.bbox\n      : undefined;\n    featureId = isFeatureCollection\n      ? geojson.features[i].id\n      : isFeature\n      ? geojson.id\n      : undefined;\n    isGeometryCollection = geometryMaybeCollection\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\n      : false;\n    stopG = isGeometryCollection\n      ? geometryMaybeCollection.geometries.length\n      : 1;\n\n    for (g = 0; g < stopG; g++) {\n      geometry = isGeometryCollection\n        ? geometryMaybeCollection.geometries[g]\n        : geometryMaybeCollection;\n\n      // Handle null Geometry\n      if (geometry === null) {\n        if (\n          callback(\n            null,\n            featureIndex,\n            featureProperties,\n            featureBBox,\n            featureId\n          ) === false\n        )\n          return false;\n        continue;\n      }\n      switch (geometry.type) {\n        case \"Point\":\n        case \"LineString\":\n        case \"MultiPoint\":\n        case \"Polygon\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\": {\n          if (\n            callback(\n              geometry,\n              featureIndex,\n              featureProperties,\n              featureBBox,\n              featureId\n            ) === false\n          )\n            return false;\n          break;\n        }\n        case \"GeometryCollection\": {\n          for (j = 0; j < geometry.geometries.length; j++) {\n            if (\n              callback(\n                geometry.geometries[j],\n                featureIndex,\n                featureProperties,\n                featureBBox,\n                featureId\n              ) === false\n            )\n              return false;\n          }\n          break;\n        }\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n    // Only increase `featureIndex` per each feature\n    featureIndex++;\n  }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  geomEach(\n    geojson,\n    function (\n      currentGeometry,\n      featureIndex,\n      featureProperties,\n      featureBBox,\n      featureId\n    ) {\n      if (featureIndex === 0 && initialValue === undefined)\n        previousValue = currentGeometry;\n      else\n        previousValue = callback(\n          previousValue,\n          currentGeometry,\n          featureIndex,\n          featureProperties,\n          featureBBox,\n          featureId\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n  geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n    // Callback for single geometry\n    var type = geometry === null ? null : geometry.type;\n    switch (type) {\n      case null:\n      case \"Point\":\n      case \"LineString\":\n      case \"Polygon\":\n        if (\n          callback(\n            feature(geometry, properties, { bbox: bbox, id: id }),\n            featureIndex,\n            0\n          ) === false\n        )\n          return false;\n        return;\n    }\n\n    var geomType;\n\n    // Callback for multi-geometry\n    switch (type) {\n      case \"MultiPoint\":\n        geomType = \"Point\";\n        break;\n      case \"MultiLineString\":\n        geomType = \"LineString\";\n        break;\n      case \"MultiPolygon\":\n        geomType = \"Polygon\";\n        break;\n    }\n\n    for (\n      var multiFeatureIndex = 0;\n      multiFeatureIndex < geometry.coordinates.length;\n      multiFeatureIndex++\n    ) {\n      var coordinate = geometry.coordinates[multiFeatureIndex];\n      var geom = {\n        type: geomType,\n        coordinates: coordinate,\n      };\n      if (\n        callback(feature(geom, properties), featureIndex, multiFeatureIndex) ===\n        false\n      )\n        return false;\n    }\n  });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  flattenEach(\n    geojson,\n    function (currentFeature, featureIndex, multiFeatureIndex) {\n      if (\n        featureIndex === 0 &&\n        multiFeatureIndex === 0 &&\n        initialValue === undefined\n      )\n        previousValue = currentFeature;\n      else\n        previousValue = callback(\n          previousValue,\n          currentFeature,\n          featureIndex,\n          multiFeatureIndex\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n  flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {\n    var segmentIndex = 0;\n\n    // Exclude null Geometries\n    if (!feature$$1.geometry) return;\n    // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n    var type = feature$$1.geometry.type;\n    if (type === \"Point\" || type === \"MultiPoint\") return;\n\n    // Generate 2-vertex line segments\n    var previousCoords;\n    var previousFeatureIndex = 0;\n    var previousMultiIndex = 0;\n    var prevGeomIndex = 0;\n    if (\n      coordEach(\n        feature$$1,\n        function (\n          currentCoord,\n          coordIndex,\n          featureIndexCoord,\n          multiPartIndexCoord,\n          geometryIndex\n        ) {\n          // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n          if (\n            previousCoords === undefined ||\n            featureIndex > previousFeatureIndex ||\n            multiPartIndexCoord > previousMultiIndex ||\n            geometryIndex > prevGeomIndex\n          ) {\n            previousCoords = currentCoord;\n            previousFeatureIndex = featureIndex;\n            previousMultiIndex = multiPartIndexCoord;\n            prevGeomIndex = geometryIndex;\n            segmentIndex = 0;\n            return;\n          }\n          var currentSegment = lineString(\n            [previousCoords, currentCoord],\n            feature$$1.properties\n          );\n          if (\n            callback(\n              currentSegment,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex,\n              segmentIndex\n            ) === false\n          )\n            return false;\n          segmentIndex++;\n          previousCoords = currentCoord;\n        }\n      ) === false\n    )\n      return false;\n  });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentIndex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  var started = false;\n  segmentEach(\n    geojson,\n    function (\n      currentSegment,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex,\n      segmentIndex\n    ) {\n      if (started === false && initialValue === undefined)\n        previousValue = currentSegment;\n      else\n        previousValue = callback(\n          previousValue,\n          currentSegment,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex,\n          segmentIndex\n        );\n      started = true;\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n  // validation\n  if (!geojson) throw new Error(\"geojson is required\");\n\n  flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {\n    if (feature$$1.geometry === null) return;\n    var type = feature$$1.geometry.type;\n    var coords = feature$$1.geometry.coordinates;\n    switch (type) {\n      case \"LineString\":\n        if (callback(feature$$1, featureIndex, multiFeatureIndex, 0, 0) === false)\n          return false;\n        break;\n      case \"Polygon\":\n        for (\n          var geometryIndex = 0;\n          geometryIndex < coords.length;\n          geometryIndex++\n        ) {\n          if (\n            callback(\n              lineString(coords[geometryIndex], feature$$1.properties),\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false\n          )\n            return false;\n        }\n        break;\n    }\n  });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  lineEach(\n    geojson,\n    function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n      if (featureIndex === 0 && initialValue === undefined)\n        previousValue = currentLine;\n      else\n        previousValue = callback(\n          previousValue,\n          currentLine,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var segmentIndex = options.segmentIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n\n  // Find SegmentIndex\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n      if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n      return lineString(\n        [coords[segmentIndex], coords[segmentIndex + 1]],\n        properties,\n        options\n      );\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[geometryIndex][segmentIndex],\n          coords[geometryIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][segmentIndex],\n          coords[multiFeatureIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex =\n          coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][geometryIndex][segmentIndex],\n          coords[multiFeatureIndex][geometryIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var coordIndex = options.coordIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n\n  // Find Coord Index\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n      return point(coords, properties, options);\n    case \"MultiPoint\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      return point(coords[multiFeatureIndex], properties, options);\n    case \"LineString\":\n      if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n      return point(coords[coordIndex], properties, options);\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[geometryIndex].length + coordIndex;\n      return point(coords[geometryIndex][coordIndex], properties, options);\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[multiFeatureIndex].length + coordIndex;\n      return point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex =\n          coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n      return point(\n        coords[multiFeatureIndex][geometryIndex][coordIndex],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\n\nexport { coordEach, coordReduce, propEach, propReduce, featureEach, featureReduce, coordAll, geomEach, geomReduce, flattenEach, flattenReduce, segmentEach, segmentReduce, lineEach, lineReduce, findSegment, findPoint };\n","import { coordEach } from \"@turf/meta\";\n/**\n * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.\n *\n * @name bbox\n * @param {GeoJSON} geojson any GeoJSON object\n * @returns {BBox} bbox extent in [minX, minY, maxX, maxY] order\n * @example\n * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]]);\n * var bbox = turf.bbox(line);\n * var bboxPolygon = turf.bboxPolygon(bbox);\n *\n * //addToMap\n * var addToMap = [line, bboxPolygon]\n */\nfunction bbox(geojson) {\n    var result = [Infinity, Infinity, -Infinity, -Infinity];\n    coordEach(geojson, function (coord) {\n        if (result[0] > coord[0]) {\n            result[0] = coord[0];\n        }\n        if (result[1] > coord[1]) {\n            result[1] = coord[1];\n        }\n        if (result[2] < coord[0]) {\n            result[2] = coord[0];\n        }\n        if (result[3] < coord[1]) {\n            result[3] = coord[1];\n        }\n    });\n    return result;\n}\nbbox[\"default\"] = bbox;\nexport default bbox;\n","import { isNumber, } from \"@turf/helpers\";\n/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nexport function getCoord(coord) {\n    if (!coord) {\n        throw new Error(\"coord is required\");\n    }\n    if (!Array.isArray(coord)) {\n        if (coord.type === \"Feature\" &&\n            coord.geometry !== null &&\n            coord.geometry.type === \"Point\") {\n            return coord.geometry.coordinates;\n        }\n        if (coord.type === \"Point\") {\n            return coord.coordinates;\n        }\n    }\n    if (Array.isArray(coord) &&\n        coord.length >= 2 &&\n        !Array.isArray(coord[0]) &&\n        !Array.isArray(coord[1])) {\n        return coord;\n    }\n    throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\n}\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array\n *\n * @name getCoords\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\n * @returns {Array<any>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coords = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nexport function getCoords(coords) {\n    if (Array.isArray(coords)) {\n        return coords;\n    }\n    // Feature\n    if (coords.type === \"Feature\") {\n        if (coords.geometry !== null) {\n            return coords.geometry.coordinates;\n        }\n    }\n    else {\n        // Geometry\n        if (coords.coordinates) {\n            return coords.coordinates;\n        }\n    }\n    throw new Error(\"coords must be GeoJSON Feature, Geometry Object or an Array\");\n}\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nexport function containsNumber(coordinates) {\n    if (coordinates.length > 1 &&\n        isNumber(coordinates[0]) &&\n        isNumber(coordinates[1])) {\n        return true;\n    }\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error(\"coordinates must only contain numbers\");\n}\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function geojsonType(value, type, name) {\n    if (!type || !name) {\n        throw new Error(\"type and name required\");\n    }\n    if (!value || value.type !== type) {\n        throw new Error(\"Invalid input to \" +\n            name +\n            \": must be a \" +\n            type +\n            \", given \" +\n            value.type);\n    }\n}\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nexport function featureOf(feature, type, name) {\n    if (!feature) {\n        throw new Error(\"No feature passed\");\n    }\n    if (!name) {\n        throw new Error(\".featureOf() requires a name\");\n    }\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n        throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error(\"Invalid input to \" +\n            name +\n            \": must be a \" +\n            type +\n            \", given \" +\n            feature.geometry.type);\n    }\n}\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function collectionOf(featureCollection, type, name) {\n    if (!featureCollection) {\n        throw new Error(\"No featureCollection passed\");\n    }\n    if (!name) {\n        throw new Error(\".collectionOf() requires a name\");\n    }\n    if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\n        throw new Error(\"Invalid input to \" + name + \", FeatureCollection required\");\n    }\n    for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {\n        var feature = _a[_i];\n        if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n            throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error(\"Invalid input to \" +\n                name +\n                \": must be a \" +\n                type +\n                \", given \" +\n                feature.geometry.type);\n        }\n    }\n}\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nexport function getGeom(geojson) {\n    if (geojson.type === \"Feature\") {\n        return geojson.geometry;\n    }\n    return geojson;\n}\n/**\n * Get GeoJSON object's type, Geometry type is prioritize.\n *\n * @param {GeoJSON} geojson GeoJSON object\n * @param {string} [name=\"geojson\"] name of the variable to display in error message (unused)\n * @returns {string} GeoJSON type\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getType(point)\n * //=\"Point\"\n */\nexport function getType(geojson, _name) {\n    if (geojson.type === \"FeatureCollection\") {\n        return \"FeatureCollection\";\n    }\n    if (geojson.type === \"GeometryCollection\") {\n        return \"GeometryCollection\";\n    }\n    if (geojson.type === \"Feature\" && geojson.geometry !== null) {\n        return geojson.geometry.type;\n    }\n    return geojson.type;\n}\n","import { getCoord } from \"@turf/invariant\";\nimport { radiansToLength, degreesToRadians } from \"@turf/helpers\";\n//http://en.wikipedia.org/wiki/Haversine_formula\n//http://www.movable-type.co.uk/scripts/latlong.html\n/**\n * Calculates the distance between two {@link Point|points} in degrees, radians, miles, or kilometers.\n * This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.\n *\n * @name distance\n * @param {Coord} from origin point\n * @param {Coord} to destination point\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @returns {number} distance between the two points\n * @example\n * var from = turf.point([-75.343, 39.984]);\n * var to = turf.point([-75.534, 39.123]);\n * var options = {units: 'miles'};\n *\n * var distance = turf.distance(from, to, options);\n *\n * //addToMap\n * var addToMap = [from, to];\n * from.properties.distance = distance;\n * to.properties.distance = distance;\n */\nfunction distance(from, to, options) {\n    if (options === void 0) { options = {}; }\n    var coordinates1 = getCoord(from);\n    var coordinates2 = getCoord(to);\n    var dLat = degreesToRadians(coordinates2[1] - coordinates1[1]);\n    var dLon = degreesToRadians(coordinates2[0] - coordinates1[0]);\n    var lat1 = degreesToRadians(coordinates1[1]);\n    var lat2 = degreesToRadians(coordinates2[1]);\n    var a = Math.pow(Math.sin(dLat / 2), 2) +\n        Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);\n    return radiansToLength(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), options.units);\n}\nexport default distance;\n","import { degreesToRadians, radiansToDegrees } from \"@turf/helpers\";\nimport { getCoord } from \"@turf/invariant\";\n// http://en.wikipedia.org/wiki/Haversine_formula\n// http://www.movable-type.co.uk/scripts/latlong.html\n/**\n * Takes two {@link Point|points} and finds the geographic bearing between them,\n * i.e. the angle measured in degrees from the north line (0 degrees)\n *\n * @name bearing\n * @param {Coord} start starting Point\n * @param {Coord} end ending Point\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.final=false] calculates the final bearing if true\n * @returns {number} bearing in decimal degrees, between -180 and 180 degrees (positive clockwise)\n * @example\n * var point1 = turf.point([-75.343, 39.984]);\n * var point2 = turf.point([-75.534, 39.123]);\n *\n * var bearing = turf.bearing(point1, point2);\n *\n * //addToMap\n * var addToMap = [point1, point2]\n * point1.properties['marker-color'] = '#f00'\n * point2.properties['marker-color'] = '#0f0'\n * point1.properties.bearing = bearing\n */\nexport default function bearing(start, end, options) {\n    if (options === void 0) { options = {}; }\n    // Reverse calculation\n    if (options.final === true) {\n        return calculateFinalBearing(start, end);\n    }\n    var coordinates1 = getCoord(start);\n    var coordinates2 = getCoord(end);\n    var lon1 = degreesToRadians(coordinates1[0]);\n    var lon2 = degreesToRadians(coordinates2[0]);\n    var lat1 = degreesToRadians(coordinates1[1]);\n    var lat2 = degreesToRadians(coordinates2[1]);\n    var a = Math.sin(lon2 - lon1) * Math.cos(lat2);\n    var b = Math.cos(lat1) * Math.sin(lat2) -\n        Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);\n    return radiansToDegrees(Math.atan2(a, b));\n}\n/**\n * Calculates Final Bearing\n *\n * @private\n * @param {Coord} start starting Point\n * @param {Coord} end ending Point\n * @returns {number} bearing\n */\nfunction calculateFinalBearing(start, end) {\n    // Swap start & end\n    var bear = bearing(end, start);\n    bear = (bear + 180) % 360;\n    return bear;\n}\n","// http://en.wikipedia.org/wiki/Haversine_formula\n// http://www.movable-type.co.uk/scripts/latlong.html\nimport { degreesToRadians, lengthToRadians, point, radiansToDegrees, } from \"@turf/helpers\";\nimport { getCoord } from \"@turf/invariant\";\n/**\n * Takes a {@link Point} and calculates the location of a destination point given a distance in\n * degrees, radians, miles, or kilometers; and bearing in degrees.\n * This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.\n *\n * @name destination\n * @param {Coord} origin starting point\n * @param {number} distance distance from the origin point\n * @param {number} bearing ranging from -180 to 180\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] miles, kilometers, degrees, or radians\n * @param {Object} [options.properties={}] Translate properties to Point\n * @returns {Feature<Point>} destination point\n * @example\n * var point = turf.point([-75.343, 39.984]);\n * var distance = 50;\n * var bearing = 90;\n * var options = {units: 'miles'};\n *\n * var destination = turf.destination(point, distance, bearing, options);\n *\n * //addToMap\n * var addToMap = [point, destination]\n * destination.properties['marker-color'] = '#f00';\n * point.properties['marker-color'] = '#0f0';\n */\nexport default function destination(origin, distance, bearing, options) {\n    if (options === void 0) { options = {}; }\n    // Handle input\n    var coordinates1 = getCoord(origin);\n    var longitude1 = degreesToRadians(coordinates1[0]);\n    var latitude1 = degreesToRadians(coordinates1[1]);\n    var bearingRad = degreesToRadians(bearing);\n    var radians = lengthToRadians(distance, options.units);\n    // Main\n    var latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians) +\n        Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearingRad));\n    var longitude2 = longitude1 +\n        Math.atan2(Math.sin(bearingRad) * Math.sin(radians) * Math.cos(latitude1), Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2));\n    var lng = radiansToDegrees(longitude2);\n    var lat = radiansToDegrees(latitude2);\n    return point([lng, lat], options.properties);\n}\n","import bearing from \"@turf/bearing\";\nimport destination from \"@turf/destination\";\nimport measureDistance from \"@turf/distance\";\nimport { point } from \"@turf/helpers\";\nimport { getGeom } from \"@turf/invariant\";\n/**\n * Takes a {@link LineString} and returns a {@link Point} at a specified distance along the line.\n *\n * @name along\n * @param {Feature<LineString>} line input line\n * @param {number} distance distance along the line\n * @param {Object} [options] Optional parameters\n * @param {string} [options.units=\"kilometers\"] can be degrees, radians, miles, or kilometers\n * @returns {Feature<Point>} Point `distance` `units` along the line\n * @example\n * var line = turf.lineString([[-83, 30], [-84, 36], [-78, 41]]);\n * var options = {units: 'miles'};\n *\n * var along = turf.along(line, 200, options);\n *\n * //addToMap\n * var addToMap = [along, line]\n */\nexport default function along(line, distance, options) {\n    if (options === void 0) { options = {}; }\n    // Get Coords\n    var geom = getGeom(line);\n    var coords = geom.coordinates;\n    var travelled = 0;\n    for (var i = 0; i < coords.length; i++) {\n        if (distance >= travelled && i === coords.length - 1) {\n            break;\n        }\n        else if (travelled >= distance) {\n            var overshot = distance - travelled;\n            if (!overshot) {\n                return point(coords[i]);\n            }\n            else {\n                var direction = bearing(coords[i], coords[i - 1]) - 180;\n                var interpolated = destination(coords[i], overshot, direction, options);\n                return interpolated;\n            }\n        }\n        else {\n            travelled += measureDistance(coords[i], coords[i + 1], options);\n        }\n    }\n    return point(coords[coords.length - 1]);\n}\n","import mapboxgl from 'mapbox-gl';\nimport {lineString, featureCollection, point} from '@turf/helpers';\nimport length from '@turf/length';\nimport along from '@turf/along';\n\ninterface Input {\n  start: mapboxgl.GeoJSONSourceOptions['data'];\n  end: mapboxgl.GeoJSONSourceOptions['data'];\n  sourceId: string;\n  highlightedSourceId: string;\n  highlightedId: string | number | null;\n  map: mapboxgl.Map;\n}\n\ninterface PointFeature {\n  type: 'Feature',\n  geometry: {\n    type: 'Point',\n    coordinates: [number, number],\n  },\n  properties: {\n    id: string,\n    country: string,\n    city: string,\n  }\n}\n\ninterface LineStringFeature {\n  type: 'Feature',\n  geometry: {\n    type: 'LineString',\n    coordinates: [number, number][],\n  },\n  properties: {\n    id: string,\n    country: string,\n    city: string,\n  }\n}\n\nconst steps = 120;\n\nconst animatePoints = (input: Input) => {\n  const {map, sourceId, highlightedId, highlightedSourceId} = input;\n  const start = input.start as any;\n  const end = input.end as any;\n\n  const routes = {\n    ...start.features,\n    features: start.features.map((startFeature: PointFeature) => {\n      const endFeature: PointFeature =\n        end.features.find((f: PointFeature) => f.properties.id.toString() === startFeature.properties.id.toString());\n      const route = lineString(\n        [startFeature.geometry.coordinates, endFeature.geometry.coordinates],\n        {...startFeature.properties},\n      );\n      const lineDistance = length(route);\n      const arc: [number, number][] = [];\n      for (let i = 0; i < lineDistance; i += lineDistance / steps) {\n        const segment = along(route, i);\n        arc.push(segment.geometry.coordinates as [number, number]);\n      }\n      route.geometry.coordinates = arc;\n      return route;\n    }),\n  }\n\n  let counter = 0;\n  let ease = 1;\n  function animate() {\n    const index = counter >= steps ? steps - 1 : Math.floor(counter);\n    let highlighted: any | undefined;\n    const points = routes.features.map((feature: LineStringFeature) => {\n      const newPoint = point(\n        feature.geometry.coordinates[index],\n        {...feature.properties}\n      )\n      if (highlightedId !== null && feature.properties.id.toString() === highlightedId.toString()) {\n        highlighted = {\n          ...newPoint,\n          properties: {\n            ...newPoint.properties,\n            icon: 'arrow_down',\n          }\n        };\n      }\n      return newPoint;\n    });\n\n    const source = map.getSource(sourceId);\n    if (source) {\n      (source as any).setData(featureCollection(points));\n    }\n\n    if (highlighted) {\n      const highlightedSource = map.getSource(highlightedSourceId);\n      if (highlightedSource) {\n        (highlightedSource as any).setData(highlighted);\n      }\n    }\n   \n    // Request the next frame of animation as long as the end has not been reached\n    if (counter < steps) {\n      requestAnimationFrame(animate);\n    } else {\n      const source = map.getSource(sourceId);\n      if (source) {\n        (source as any).setData(end);\n      }\n      if (highlighted) {\n        const endNode = end.features.find((f: any) => highlightedId !== null && f.properties.id.toString() === highlightedId.toString());\n        if (endNode) {\n          highlighted = {\n            ...endNode,\n            properties: {\n              ...endNode.properties,\n              icon: 'arrow_down',\n            }\n          };\n          const highlightedSource = map.getSource(highlightedSourceId);\n          if (highlightedSource) {\n            (highlightedSource as any).setData(highlighted);\n          }\n        }\n      }\n    }\n    ease = counter < steps / 2 ? ease * 1.09 : ease * 0.92;\n    counter = counter + ease;\n  }\n  animate();\n}\n\nexport default animatePoints;\n","import mapboxgl from 'mapbox-gl';\n\nexport enum MapMode {\n  GEO = 'GEO',\n  UMAP = 'UMAP',\n}\n\nexport const defaultGeoJsonPoint: mapboxgl.GeoJSONSourceOptions['data'] = {\n  type: 'Feature',\n  properties: {},\n  geometry: {\n    type: 'Point',\n    coordinates: [],\n  },\n};\n","import distance from \"@turf/distance\";\nimport { segmentReduce } from \"@turf/meta\";\n/**\n * Takes a {@link GeoJSON} and measures its length in the specified units, {@link (Multi)Point}'s distance are ignored.\n *\n * @name length\n * @param {Feature<LineString|MultiLineString>} geojson GeoJSON to measure\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units=kilometers] can be degrees, radians, miles, or kilometers\n * @returns {number} length of GeoJSON\n * @example\n * var line = turf.lineString([[115, -32], [131, -22], [143, -25], [150, -34]]);\n * var length = turf.length(line, {units: 'miles'});\n *\n * //addToMap\n * var addToMap = [line];\n * line.properties.distance = length;\n */\nexport default function length(geojson, options) {\n    if (options === void 0) { options = {}; }\n    // Calculate distance from 2-vertex line segments\n    return segmentReduce(geojson, function (previousValue, segment) {\n        var coords = segment.geometry.coordinates;\n        return previousValue + distance(coords[0], coords[1], options);\n    }, 0);\n}\n","import {scaleQuantize} from 'd3-scale';\nimport {extent} from 'd3-array';\n\nexport const colorByCountryColorMap = [\n  {id: \"United States\", color: \"#696969\"},\n  {id: \"Canada\", color: \"#1E90FF\"},\n  {id: \"Peru\", color: \"#B22222\"},\n  {id: \"Brazil\", color: \"#D2691E\"},\n  {id: \"Chile\", color: \"#228B22\"},\n  {id: \"Argentina\", color: \"#FF00FF\"},\n  {id: \"Spain\", color: \"#DCDCDC\"},\n  {id: \"Morocco\", color: \"#32CD32\"},\n  {id: \"Portugal\", color: \"#FFD700\"},\n  {id: \"United Kingdom\", color: \"#DAA520\"},\n  {id: \"France\", color: \"#808080\"},\n  {id: \"Belgium\", color: \"#808080\"},\n  {id: \"Germany\", color: \"#008000\"},\n  {id: \"Italy\", color: \"#ADFF2F\"},\n  {id: \"Norway\", color: \"#F0FFF0\"},\n  {id: \"Sweden\", color: \"#FF69B4\"},\n  {id: \"Denmark\", color: \"#CD5C5C\"},\n  {id: \"Czech Republic\", color: \"#4B0082\"},\n  {id: \"Slovenia\", color: \"#FFFFF0\"},\n  {id: \"Poland\", color: \"#F0E68C\"},\n  {id: \"Austria\", color: \"#E6E6FA\"},\n  {id: \"Croatia\", color: \"#FFF0F5\"},\n  {id: \"Russia\", color: \"#7CFC00\"},\n  {id: \"Hungary\", color: \"#FFFACD\"},\n  {id: \"Finland\", color: \"#ADD8E6\"},\n  {id: \"Estonia\", color: \"#F08080\"},\n  {id: \"Latvia\", color: \"#E0FFFF\"},\n  {id: \"Lithuania\", color: \"#FAFAD2\"},\n  {id: \"Greece\", color: \"#D3D3D3\"},\n  {id: \"Romania\", color: \"#D3D3D3\"},\n  {id: \"Israel\", color: \"#90EE90\"},\n  {id: \"India\", color: \"#FFB6C1\"},\n  {id: \"China\", color: \"#FFA07A\"},\n  {id: \"Thailand\", color: \"#20B2AA\"},\n  {id: \"Singapore\", color: \"#87CEFA\"},\n  {id: \"Taiwan\", color: \"#778899\"},\n  {id: \"Japan\", color: \"#778899\"},\n  {id: \"Philippines\", color: \"#B0C4DE\"},\n]\n\nconst proximityColors = [\n   '#F9E200',\n   '#E3260B',\n   '#C9178E',\n   '#6E1DB2',\n   '#223E9A',\n];\n\nexport const createProximityScale = (values: number[]) => {\n  const scale: (val: number) => string = scaleQuantize()\n    .domain(extent(values) as [number, number])\n    .range(proximityColors as any[]) as any;\n  return scale;\n}","import mapboxgl from 'mapbox-gl';\nimport bbox from '@turf/bbox';\nimport animatePoints from './animatePoints';\nimport initInteractions from './interactions';\nimport changeColors from './changeColors';\nimport {MapMode, defaultGeoJsonPoint} from './Utils';\n\ninterface Input {\n  container: HTMLElement;\n  mapStyle: string;\n  accessToken: string;\n  cityGeoJson: mapboxgl.GeoJSONSourceOptions['data'];\n  cityUMapJson: mapboxgl.GeoJSONSourceOptions['data'];\n  initialMode: MapMode;\n  getPopupHTMLContent: undefined | ((datum: {id: string, country: string, city: string}) => string);\n}\n\nexport interface Output {\n  map: mapboxgl.Map;\n  setToGeoMap: () => void;\n  setToUMap: () => void;\n  setColors: (colorMap: {id: string, color: string}[]) => void;\n  setNewCenter: (center: [number, number]) => void;\n  setHighlighted: (id: number | string | null) => void;\n}\n\nconst cityNodesSourceId = 'city-nodes-source-id';\nconst highlightedNodeSourceId = 'highlighted-city-node-source-id';\nconst overlaySourceId = 'city-overlay-source-id';\n\nconst overlayPath = [\n  [\n    [-180, -90],\n    [-180, 90],\n    [180, 90],\n    [180, -90],\n    [-180, -90],\n  ]\n]\nconst hiddenCircle: mapboxgl.GeoJSONSourceOptions['data'] =\n  {type: 'Feature', geometry: {type: 'Polygon', coordinates: overlayPath}, properties: {opacity: 0}};\nconst overlayCircle: mapboxgl.GeoJSONSourceOptions['data'] =\n  {type: 'Feature', geometry: {type: 'Polygon', coordinates: overlayPath}, properties: {opacity: 1}};\n\nconst initMap = (input: Input): Output => {\n  const {\n    container, accessToken, cityGeoJson, cityUMapJson, initialMode, mapStyle,\n    getPopupHTMLContent,\n  } = input;\n  mapboxgl.accessToken = accessToken;\n\n  const geoBbox: any = bbox(cityGeoJson);\n  const geoUMapBbox: any = bbox(cityUMapJson);\n\n  const map = new mapboxgl.Map({\n    container,\n    style: mapStyle, // stylesheet location\n    center: [0, 80], // starting position [lng, lat]\n    zoom: 1.45, // starting zoom\n    maxZoom: 15.5,\n    bounds: geoBbox,\n  });\n\n  let mapLoaded = false;\n  let centerOverride = false;\n\n  map.on('load', () => {\n    mapLoaded = true;\n    if (!centerOverride) {\n      map.fitBounds(geoBbox, {\n        padding: 50,\n        animate: true,\n      });\n    }\n\n    map.addSource(overlaySourceId, {\n      type: 'geojson',\n      data: initialMode === MapMode.GEO ? hiddenCircle : overlayCircle,\n    });\n\n    map.addLayer({\n      id: overlaySourceId,\n      type: 'fill',\n      source: overlaySourceId,\n      paint: {\n        'fill-color': '#fff',\n        'fill-opacity': ['get', 'opacity'],\n      }\n    });\n\n    map.addSource(cityNodesSourceId, {\n      type: 'geojson',\n      data: initialMode === MapMode.GEO ? cityGeoJson : cityUMapJson,\n    });\n\n    map.addLayer({\n      id: cityNodesSourceId,\n      type: 'circle',\n      source: cityNodesSourceId,\n      paint: {\n        // make circles larger as the user zooms from z12 to z22\n        'circle-radius': [\n          'interpolate',\n          ['linear', 1.96],\n          ['zoom'],\n          0, 2,\n          22, 20,\n        ],\n        'circle-color': ['get', 'fill'],\n      },\n    });\n\n    map.addSource(highlightedNodeSourceId, {\n      type: 'geojson',\n      data: defaultGeoJsonPoint,\n    });\n\n    map.addLayer({\n      id: highlightedNodeSourceId,\n      type: 'symbol',\n      source: highlightedNodeSourceId,\n        layout: {\n          'icon-image': ['get', 'icon'],\n          'icon-size': [\n              'interpolate',\n              ['exponential', 0.96],\n              ['zoom'],\n              0,\n              0.5,\n              22,\n              2,\n          ],\n          'icon-offset': [0, -15],\n          'icon-allow-overlap': true,\n          'icon-ignore-placement': true\n      }\n    });\n\n    initInteractions({map, sourceId: cityNodesSourceId, getPopupHTMLContent});\n  });\n\n  let mode: MapMode = initialMode;\n  let highlightedId: string | number | null = null;\n\n  const setToGeoMap = () => {\n    if (mapLoaded) {\n      map.setRenderWorldCopies(true);\n      const duration = 200;\n      map.fitBounds(geoBbox, {\n        padding: {top: 100, bottom:0, left: 50, right: 50},\n        animate: true,\n        duration,\n      });\n      setTimeout(() => {\n        animatePoints({\n          start: cityUMapJson,\n          end: cityGeoJson,\n          sourceId: cityNodesSourceId,\n          map, highlightedId,\n          highlightedSourceId: highlightedNodeSourceId,\n        });\n      }, duration)\n      const overlaySource = map.getSource(overlaySourceId);\n      if (overlaySource) {\n        (overlaySource as any).setData(hiddenCircle);\n      }\n      mode = MapMode.GEO;\n    }\n  };\n\n  const setToUMap = () => {\n    if (mapLoaded) {\n      map.setRenderWorldCopies(false);\n      const duration = 200;\n      map.fitBounds(geoUMapBbox, {\n        padding: {top: 100, bottom:0, left: 50, right: 50},\n        animate: true,\n        duration,\n      });\n      setTimeout(() => {\n        animatePoints({\n          start: cityGeoJson,\n          end: cityUMapJson,\n          sourceId: cityNodesSourceId,\n          map, highlightedId,\n          highlightedSourceId: highlightedNodeSourceId,\n        })\n      }, duration)\n      const overlaySource = map.getSource(overlaySourceId);\n      if (overlaySource) {\n        (overlaySource as any).setData(overlayCircle);\n      }\n      mode = MapMode.UMAP;\n    }\n  };\n\n  const setColors = (colorMap: {id: string, color: string}[]) => {\n    changeColors({\n      sourceId: cityNodesSourceId,\n      map, colorMap, mode,\n      cityGeoJson,\n      cityUMapJson,\n    });\n  }\n\n  const setNewCenter = (center: [number, number]) => {\n    if (mode === MapMode.GEO) {\n      centerOverride = true;\n      map.jumpTo({\n        center,\n        zoom: 3,\n      });\n    }\n  };\n\n  const setHighlighted = (id: number | string | null) => {\n    const updateHighlightedPointSource = () => {\n      const source = map.getSource(highlightedNodeSourceId);\n      if (id !== null && source) {\n        highlightedId = id;\n        const data: any = mode === MapMode.UMAP ? cityUMapJson : cityGeoJson;\n        const targetPoint = data.features.find((d: any) => d.properties.id.toString() === id.toString());\n        if (targetPoint) {\n          const properties = {\n            ...targetPoint.properties,\n            icon: 'arrow_down',\n          };\n          (source as any).setData({\n            ...targetPoint,\n            properties,\n          });\n        }\n      } else if (source) {\n        (source as any).setData(defaultGeoJsonPoint);\n      }\n    }\n\n    if (mapLoaded) {\n      updateHighlightedPointSource();\n    } else {\n      const updateHighlightedPointSourceOnLoad = () => {\n        updateHighlightedPointSource();\n        map.off('load', updateHighlightedPointSourceOnLoad);\n      };\n      map.on('load', updateHighlightedPointSourceOnLoad);\n    }\n  };\n\n  return {\n    map, setToGeoMap, setToUMap, setColors, setNewCenter, setHighlighted,\n  };\n};\n\nexport default initMap;\n","import mapboxgl from 'mapbox-gl';\n\ninterface Input {\n  map: mapboxgl.Map;\n  sourceId: string;\n  getPopupHTMLContent: undefined | ((datum: {id: string, country: string, city: string}) => string);\n}\n\nconst initInteractions = (input: Input) => {\n  const {\n    map, sourceId, getPopupHTMLContent,\n  } = input;\n\n  var popup = new mapboxgl.Popup({\n    closeButton: false,\n    closeOnClick: false\n  });\n\n  // Change the cursor to a pointer when the mouse is over the places layer.\n  map.on('mouseenter', sourceId, (e) => {\n    map.getCanvas().style.cursor = 'pointer';\n\n    const coordinates = (e.features as any)[0].geometry.coordinates.slice();\n    const city = (e.features as any)[0].properties.city;\n    const country = (e.features as any)[0].properties.country;\n    const locationText = city + ', ' + country;\n    // Ensure that if the map is zoomed out such that multiple\n    // copies of the feature are visible, the popup appears\n    // over the copy being pointed to.\n    while (Math.abs(e.lngLat.lng - coordinates[0]) > 180) {\n      coordinates[0] += e.lngLat.lng > coordinates[0] ? 360 : -360;\n    }\n\n    const popupContent = getPopupHTMLContent ? getPopupHTMLContent((e.features as any)[0].properties) : locationText;\n     \n    // Populate the popup and set its coordinates\n    // based on the feature found.\n    popup.setLngLat(coordinates).setHTML(popupContent).addTo(map);\n  });\n\n  // Change it back to a pointer when it leaves.\n  map.on('mouseleave', sourceId, () => {\n    map.getCanvas().style.cursor = '';\n    popup.remove();\n  });\n\n};\n\nexport default initInteractions;\n","import mapboxgl from 'mapbox-gl';\nimport {MapMode} from './Utils';\n\n\ninterface Input {\n  sourceId: string;\n  map: mapboxgl.Map;\n  mode: MapMode;\n  colorMap: {id: string, color: string}[];\n  cityGeoJson: mapboxgl.GeoJSONSourceOptions['data'];\n  cityUMapJson: mapboxgl.GeoJSONSourceOptions['data'];\n}\n\nconst changeColors = (input: Input) => {\n  const {map, sourceId, colorMap, mode} = input;\n  const defaultColor = '#F9E200';\n  const cityGeoJson = input.cityGeoJson as any;\n  const cityUMapJson = input.cityUMapJson as any;\n  cityGeoJson.features.map((d: any) => {\n    const newColorTarget = colorMap.find(c => c.id.toString() === d.properties.id.toString());\n    d.properties = {...d.properties, fill: newColorTarget ? newColorTarget.color : defaultColor};\n  })\n  cityUMapJson.features.map((d: any) => {\n    const newColorTarget = colorMap.find(c => c.id.toString() === d.properties.id.toString());\n    d.properties = {...d.properties, fill: newColorTarget ? newColorTarget.color : defaultColor};\n  })\n\n  const source = map.getSource(sourceId);\n  if (source) {\n    const data = mode === MapMode.UMAP ? cityUMapJson : cityGeoJson;\n    (source as any).setData({...data});\n  }\n}\n\nexport default changeColors;\n","import 'mapbox-gl/dist/mapbox-gl.css';\nimport React, {useEffect, useState, createContext, useContext} from 'react';\nimport initMap, {Output} from './map';\nimport {MapMode} from './map/Utils';\n\ntype MapState = { intialized: false } | ( {intialized: true} & Output);\nconst MapContext = createContext<MapState>({intialized: false});\n\nconst useMapContext = () => {\n  const mapContext = useContext(MapContext);\n  return mapContext;\n};\n\ninterface Props {\n  accessToken: string;\n  mapStyle: string;\n  rootRef: React.MutableRefObject<HTMLDivElement | null>;\n  children: React.ReactNode;\n  cityGeoJson: mapboxgl.GeoJSONSourceOptions['data'] | undefined;\n  cityUMapJson: mapboxgl.GeoJSONSourceOptions['data'] | undefined;\n  initialMode?: MapMode;\n  getPopupHTMLContent?: undefined | ((datum: {id: string, country: string, city: string}) => string);\n}\n\nconst CitySpaceMap = (props: Props) => {\n  const {\n    accessToken, rootRef, children, cityGeoJson, cityUMapJson, initialMode, mapStyle,\n    getPopupHTMLContent,\n  } = props;\n  const [mapState, setMapState] = useState<MapState>({intialized: false});\n\n  useEffect(() => {\n    const container = rootRef.current;\n    if (container && !mapState.intialized && cityGeoJson && cityUMapJson) {\n      const mapOutput = initMap({\n        container, accessToken, cityGeoJson, cityUMapJson,\n        initialMode: initialMode ? initialMode : MapMode.GEO,\n        mapStyle, getPopupHTMLContent\n      });\n      setMapState({intialized: true, ...mapOutput});\n    }\n  }, [rootRef, mapState, cityGeoJson, cityUMapJson, initialMode, mapStyle, getPopupHTMLContent]);\n\n  return (\n    <MapContext.Provider value={mapState}>\n      {children}\n    </MapContext.Provider>\n  );\n};\n\nexport {\n  MapMode,\n  useMapContext,\n};\n\nexport default CitySpaceMap;\n","import {useState, useEffect} from 'react';\nimport CITIES_GEOJSON_RAW from './data/cities-geojson.json';\nimport CITIES_UMAPJSON_RAW from './data/cities-umap.json';\nimport {scaleLinear} from 'd3-scale';\nimport {extent} from 'd3-array';\nimport {colorByCountryColorMap} from './Utils';\n\nconst {point, featureCollection} = require('@turf/helpers');\nconst centroid = require('@turf/centroid').default;\n\ninterface Output {\n  loading: boolean;\n  error: any | undefined;\n  data: {\n    cityGeoJson: any;\n    cityUMapJson: any;\n  } | undefined;\n}\n\nconst useLayoutData = () => {\n  const [output, setOutput] = useState<Output>({loading: true, error: undefined, data: undefined});\n\n  useEffect(() => {\n    setTimeout(() => {\n\n      const allLatCoords: number[] = [];\n      const allLngCoords: number[] = [];\n\n      const cityGeoJson = featureCollection((CITIES_GEOJSON_RAW as any).features.map((feature: any) => {\n        const {ID_HDC_G0: id, CTR_MN_NM: country, UC_NM_MN: city } = feature.properties;\n        const colorNode = colorByCountryColorMap.find(c => c.id === country);\n        const fill = colorNode ? colorNode.color : 'gray';\n        const point = centroid(feature, {properties: {id, country, city, fill}})\n        allLngCoords.push(point.geometry.coordinates[0]);\n        allLatCoords.push(point.geometry.coordinates[1]);\n        return point;\n      }));\n\n\n      const uMapXCoords: number[] = [];\n      const uMapYCoords: number[] = [];\n      CITIES_UMAPJSON_RAW.forEach(({x, y}) => {\n        uMapXCoords.push(x);\n        uMapYCoords.push(y);\n      });\n\n\n      const minMaxLat = extent(allLatCoords) as [number, number];\n      const yToLatScale = scaleLinear()\n        .domain(extent(uMapYCoords) as [number, number])\n        .range([minMaxLat[0] * 1.65, minMaxLat[1] * 1.2]);\n\n      const minMaxLng = extent(allLngCoords) as [number, number];\n      const xToLngScale = scaleLinear()\n        .domain(extent(uMapXCoords) as [number, number])\n        .range([minMaxLng[0] * 0.9, minMaxLng[1] * 1]);\n\n      const cityUMapJson = featureCollection(CITIES_UMAPJSON_RAW.map(n => {\n        const {x, y, ID_HDC_G0: id, CTR_MN_NM: country, UC_NM_MN: city } = n;\n        const colorNode = colorByCountryColorMap.find(c => c.id === country);\n        const fill = colorNode ? colorNode.color : 'gray';\n        return point([xToLngScale(x), yToLatScale(y)], {id, country, city, fill})\n      }));\n\n      setOutput({loading: false, error: undefined, data: {cityUMapJson, cityGeoJson}});\n    }, 200)\n  }, [])\n\n  return output;\n}\n\nexport default useLayoutData;\n","import React, {useEffect} from 'react';\nimport styled from 'styled-components/macro';\nimport {useMapContext} from 'react-city-space-mapbox';\nimport BOSTON_PROXIMITY_RAW from '../data/boston-proximity-data.json';\nimport {createProximityScale, colorByCountryColorMap} from '../Utils';\nimport useLayoutData from '../useLayoutData';\n\nconst Root = styled.div`\n  position: absolute;\n  left: 0;\n  right: 0;\n  width: 100%;\n  margin: auto;\n  z-index: 100;\n  display: flex;\n  justify-content: center;\n  pointer-events: none;\n`;\n\nconst Button = styled.button`\n  pointer-events: all;\n  display: flex;\n  align-items: center;\n  margin: 1rem;\n  text-transform: uppercase;\n  font-size: 1.5rem;\n  font-family: monospace;\n  background-color: #fff;\n  border: solid 1px #dfdfdf;\n  border-radius: 4px;\n  transition: all 0.2s ease;\n  flex-shrink: 1;\n  flex-grow: 0;\n  flex-basis: 1;\n  width: min-content;\n  padding: 1rem;\n  white-space: pre-wrap;\n  cursor: pointer;\n`;\n\nconst colorScale = createProximityScale([0, ...BOSTON_PROXIMITY_RAW.map(d => d.proximity), 1]);\nconst proximityColorMap = BOSTON_PROXIMITY_RAW.map(({partnerId, proximity}) => ({id: partnerId, color: colorScale(proximity)}));\n\nconst OptionsBar = () => {\n  const mapContext = useMapContext();\n  const {data} = useLayoutData();\n\n  useEffect(() => {\n    if (mapContext.intialized && data) {\n      const currentCityFeature = data.cityGeoJson.features.find(({properties}: {properties: {id: number}}) => properties.id === 1022);\n      if (currentCityFeature) {\n        mapContext.setNewCenter(currentCityFeature.geometry.coordinates);\n        mapContext.setHighlighted(1022);\n      }\n    }\n  })\n\n  const onGeoMapClick = () => {\n    if (mapContext.intialized) {\n      mapContext.setToGeoMap();\n    }\n  }\n\n  const onUMapClick = () => {\n    if (mapContext.intialized) {\n      mapContext.setToUMap();\n    }\n  }\n\n  const onColorByCountryClick = () => {\n    if (mapContext.intialized && data) {\n      const countryColorMap = data.cityGeoJson.features.map((d: any) => {\n        const country = colorByCountryColorMap.find(c => c.id === d.properties.country);\n        return {\n          id: d.properties.id,\n          color: country ? country.color : 'gray',\n        }\n      })\n      mapContext.setColors(countryColorMap);\n    }\n  }\n\n  const onColorByCountryProximity = () => {\n    if (mapContext.intialized) {\n      mapContext.setColors(proximityColorMap);\n    }\n  }\n\n  return (\n    <Root>\n      <Button onClick={onGeoMapClick}>GeoMap</Button>\n      <Button onClick={onUMapClick}>UMap</Button>\n      <Button onClick={onColorByCountryClick}>Color By Country</Button>\n      <Button onClick={onColorByCountryProximity}>Color By Proximity</Button>\n    </Root>\n  );\n}\n\nexport default OptionsBar;\n","import React, {useRef} from 'react'\nimport CitySpaceMap from 'react-city-space-mapbox'\nimport styled from 'styled-components/macro';\nimport OptionsBar from './components/OptionsBar';\nimport useLayoutData from './useLayoutData';\n\nconst Root = styled.div`\n  position: fixed;\n  width: 100vw;\n  height: 100vh;\n`;\n\nconst accessToken =\n  'pk.eyJ1IjoiaGFydmFyZGdyb3d0aGxhYiIsImEiOiJja2tpaXkya2IwOW5mMnBvaTNjMHlsYjNpIn0.3xPcnwP6dHcC5HGXyoKDIQ';\n\nconst App = () => {\n  const rootRef = useRef<HTMLDivElement | null>(null);\n  const {data} = useLayoutData();\n\n  const renderTooltipContent = (node: {id: string, country: string, city: string}) => {\n    return `\n      <div>\n        <strong>${node.city}</strong>\n      </div>\n      <small>${node.country}</small>\n    `;\n  }\n  return (\n    <React.Fragment>\n      <CitySpaceMap\n        accessToken={accessToken}\n        mapStyle={'mapbox://styles/harvardgrowthlab/ckelvcgh70cg019qgiu39035a'}\n        rootRef={rootRef}\n        cityGeoJson={data ? data.cityGeoJson : undefined}\n        cityUMapJson={data ? data.cityUMapJson : undefined}\n        getPopupHTMLContent={renderTooltipContent}\n      >\n        <OptionsBar />\n      </CitySpaceMap>\n      <Root ref={rootRef} />\n    </React.Fragment>\n  );\n}\n\nexport default App\n","import './index.css'\n\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}